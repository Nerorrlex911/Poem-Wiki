---
description: 线程安全相关的内容
---

# 在JVM中的线程安全

首先，这个页面的目的只是为了概述如何实现线程安全。读者将获得用于进一步查阅文档的关键词，但是这里的文档应该足以理解后面的所有内容。

对于线程安全在Minestom中的应用，你不需要记住你将在这里读到的所有内容。但它将教给你有效的实践策略，并使你理解内部原理以做出更好的决策。

## 什么是线程安全?

当且仅当代码可以被多条线程调用而不会出现意外行为时，该代码被称为“线程安全”。因此，该术语并不会对性能或设计产生任何影响，它只是一种表示代码如何被访问的方式。

## 它的代价?

将单线程代码转换为多线程代码并不像创建多个线程那么容易。你将遇到的问题主要是关于内存可见性的，想象一下，在不做任何牺牲的情况下让2个线程在同一时间访问内存中的同一个变量是不可能的。同步(Synchronization)需要线程检查它是否有权访问指定方法，这就产生了性能开销，开销主要是在纳秒或微秒的级别，但如果太频繁就会导致程序无法使用。多线程应用程序中常见的问题有:

1. 竞态条件(Race-condition): 当两个或更多的线程同时访问和修改同一数据, 就有可能导致难以修复的问题
2. 死锁(DeadLock): 两个锁都在等待获取对方的锁，导致两个线程都无法继续执行

## 用什么实现?

使用现有的工具或特性来更简单地实现线程安全和高效的代码。

### 字段

字段需要一些同步机制。JVM提供了`volatile`访问标志，它强制字段始终在主内存中而不是在缓存中(还有其他一些细节不在此描述)，因此每个线程都从完全相同的位置读取值。根据你的应用程序，`ThreadLocal<T>`对象可能就足够了，你可以把它看作是一个`Map<Thread, T>`，其中Thread始终是当前线程。使字段线程安全的最简单方法是使用`final`关键字使其不可变，如果你不能改变一个字段，你就不会冒多个线程同时改变它的风险。


:::warning

让一个字段线程安全并不意味着这个对象本身是线程安全的，只是访问这个字段总是会返回正确的实例。

:::

### 方法

除了字段以外，你还需要一种方法来管理你的流程控制，这样两个方法就不会在完全相同的时间被调用，这很可能会破坏每一个非线程安全的程序(竞态条件)。线程同步是通过锁来实现的，这些锁是一种机制，它会使当前线程等待，直到有人告诉他，他现在可以打开门进去然后关门。

JVM提供了`synchronized`标签或低级的`Object#wait/notify()`方法来实现线程同步。还有一些更高级的工具，比如`CountDownLatch`，`Phaser`，甚至有一些方便的用于替换一般集合的线程安全集合! `ConcurrentHashMap`, `CopyOnWriteArrayList`, `ConcurrentLinkedQueue`, 还有很多其他内容都可以在你的[JDK](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html)中找到。

