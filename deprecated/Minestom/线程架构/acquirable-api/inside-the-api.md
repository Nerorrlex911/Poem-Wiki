---
description: 描述tick和线程安全的底层逻辑
sidebar_position: 2
---

# 内部原理

## 内部原理

你完全不需要了解这部分的任何内容就可以使用acquirable API。但是，它可以教你我们的代码结构以及它如何实现线程安全。请确保阅读之前的所有页面，以便正确理解这里的所有内容。

### Tick 架构

所有Tick分批次执行。在创建完所有批次后，每个批次都会被分配到ThreadDispatcher线程池中的一个线程。

线程的分配取决于`ThreadProvider`，默认情况下使用单个线程。

最后，线程开始运行，`UpdateManager`将等待所有线程完成。这个循环会一直持续到服务器停止。

### 对象获取

在一个批次被分配给一个线程之后，每个添加到其中的元素都会发生同样的事情。这意味着每个实体在它被tick之前就知道它将在哪个线程中tick!

这样做的优点是什么？它允许我们知道这个对象是否可以安全地访问！当你执行Acquirable#acquire时，它首先会检查当前线程是否与要获取的对象将被tick的线程相同，这意味着不需要同步，这种情况下的开销是一个简单的`Thread#currentThread`调用。

这显然是最理想的情景，但并不总是发生，如果两个线程不同，系统会如何反应？首先，它会向对象的线程发出信号，表示需要进行获取，然后阻塞当前线程，之后，它会等待接收信号的线程处理获取操作。信号在每个实体tick的开始和线程tick执行的结束时检查。

在获取操作的处理过程中，线程被阻塞，直到所有获取操作都被处理完毕，然后才能安全地继续执行。

### 总结


没有什么像魔法一样的东西，这个API也不例外。当获取操作被控制（以限制同步）并且具有适应需求的`ThreadProvider`时，它有可能使您的应用程序更快。如果你想为每个玩家拥有一个世界，那么使用一个批次来管理一个`Instance`可能是最好的解决方案。如果你设计精确，毫无耦合，(比如每3个区块都完全独立于彼此)，那么就按照这个精确的单位管理你的批次吧！